<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 为兰 若谷</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/hermes.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="为兰 若谷"><meta name="generator" content="Hexo 5.3.0"></head><body><div class="wrap"><header><a class="logo-link" href="/"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link" href="/archives/" target="_self">目录</a></li><li class="nav-list-item"><a class="nav-list-link" href="/tags/%E7%BD%91%E7%BB%9C/" target="_self">网络</a></li><li class="nav-list-item"><a class="nav-list-link" href="/tags/Linux/" target="_self">LINUX</a></li><li class="nav-list-item"><a class="nav-list-link" href="/tags/Mysql/" target="_self">MYSQL</a></li><li class="nav-list-item"><a class="nav-list-link" href="/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" target="_self">算法与数据结构</a></li></ul></header><main class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a class="post-title-link" href="/2021/03/15/Linux%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">Linux启动流程</a></h2><div class="post-info">2021年3月15日</div><div class="post-content"><ol>
<li><p> 载入BIOS的硬件信息与自我检测，找到第一个可开机设备；</p>
</li>
<li><p>读取并执行第一个开机设备中MBR的boot Loader；</p>
<p> ​    执行Boot loader主程序</p>
<p> ​    主程序载入配置文件（包括文件系统定义与主要配置文件grub.cfg）</p>
</li>
<li><p>根据boot loader载入Kernel，kernel会开始侦测硬件并载入驱动；</p>
<p> 在这一步Kernel（核心文件为/boot/vmlinuz）接管开机流程，以自己的功能重新侦测一边硬件，不一定使用BIOS侦测到的。之后挂载虚拟文件系统（/boot/initramfs），加载开机过程中所需的重要模块。</p>
</li>
<li><p>硬件驱动成功后，kennel主动调用systemd程序，并以default.target启动。</p>
<p> systemd负责准备软件执行的环境，包含系统的主机名称，网络设置，语系处理、文件系统格式等。default.target位于/etc/systemd/system/，其中包含启动的目标态（对应老版本的runlevel）与默认启动服务单元集合。</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/systemd/system/default.target</span><br><span class="line">    <span class="comment">#  This file is part of systemd.</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#  systemd is free software; you can redistribute it and/or modify it</span></span><br><span class="line">    <span class="comment">#  under the terms of the GNU Lesser General Public License as published by</span></span><br><span class="line">    <span class="comment">#  the Free Software Foundation; either version 2.1 of the License, or</span></span><br><span class="line">    <span class="comment">#  (at your option) any later version.</span></span><br><span class="line"></span><br><span class="line">    [Unit]</span><br><span class="line">    Description=Multi-User System</span><br><span class="line">    Documentation=man:systemd.special(7)</span><br><span class="line">    Requires=basic.target</span><br><span class="line">    Conflicts=rescue.service rescue.target</span><br><span class="line">    After=basic.target rescue.service rescue.target</span><br><span class="line">    AllowIsolate=yes</span><br></pre></td></tr></table></figure>
<p> 可以使用systemctl list-dependencies查看服务启动的服务，实验机结果如下：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-dependencies</span><br><span class="line">    default.target</span><br><span class="line">    ● ├─auditd.service</span><br><span class="line">    ● ├─chronyd.service</span><br><span class="line">    ● ├─crond.service</span><br><span class="line">    ● ├─dbus.service</span><br><span class="line">	...</span><br></pre></td></tr></table></figure></li>
<li><p> 执行sysinit.target，初始化系统，加载基本的核心驱动，文件系统和驱动等。</p>
</li>
<li><p> 执行basic.target加载更多功能，执行完之后，系统就已经启动完毕。</p>
</li>
<li><p> 执行mutli-user.target载入用户服务，如果目标态为图形界面，则继续加载graphical.target。</p>
</li>
</ol>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a class="post-title-link" href="/2021/03/15/ICMP/">ICMP</a></h2><div class="post-info">2021年3月15日</div><div class="post-content"><p>​    TCP/IP功能较为简单，缺少了很多功能，ICMP协议便是其中的一块补充，为IP增添了通知差错信息与控制信息的功能。</p>
<p><strong>报头</strong></p>
<table>
<thead>
<tr>
<th align="center">类型（8位）| 编码（8位）</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>校验和（16位）</strong></td>
</tr>
<tr>
<td align="center"><strong>选项数据</strong></td>
</tr>
</tbody></table>
<p><strong>常见类型与编码</strong></p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">编码</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">Echo Reply</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">0</td>
<td align="center">网络不可达</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">1</td>
<td align="center">主机不可达</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">协议不可达</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">端口不可达</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">0</td>
<td align="center">重定向</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">0</td>
<td align="center">Echo Request</td>
</tr>
</tbody></table>
<p>​    这只是ICMP类型与编码的一部分，具体可以看RFC792，以及其它相关ICMP拓展。</p>
<p><strong>具体应用</strong></p>
<ul>
<li><p>ping</p>
<p>ping命令是ICMP应用的典型代表之一，运用type8进行请求，如果目的地可到达则回复type0，否则根据情况返回对应类型编码。</p>
</li>
<li><p>tracert（windows)/ traceroute（Linux）</p>
<p>用于判断转发路径的命令，它的原理是先向目的端发送一个UDP测试报文，TTL值为1，目的端口为一个极其不常用的端口，沿途节点收到后拆包判断自己是不是目的地，不是的话TTL-1=0，向源端返回ICMP超时报文，报文中含有本机IP。源端收到后，再向目的端发送以个UDP报文，这次的TTL值+1=2。重复上述过程，每次TTL值+1，直到到达目的地后停止。</p>
</li>
</ul>
<p><strong>路由重定向</strong></p>
<p>​    不同的系统对于路由重定向报文有着不同的处理方案，绝大多数往往会直接忽略ICMP重定向报文。因为如果支持重定向，设备将需要维护一个非常庞大的路由表，会极其浪费服务器的性能，而且ICMP重定向存在着安全隐患。</p>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a class="post-title-link" href="/2021/03/14/InnoDB%E7%9A%84%E9%94%81/">InnoDB的锁</a></h2><div class="post-info">2021年3月14日</div><div class="post-content"><p>​    当遇到对临界资源进行并发访问的时候，一方面要最大化的性能，另一方面还要保障数据的一致性，而锁机制可以很好的达成这样的效果。本文主要介绍InnoDB中的锁。    </p>
<p>​    InnoDB中锁按照粒度来分可分为行级锁与表级锁。行级锁通过索引上的索引项实现，其中包含共享锁与排他锁：</p>
<ul>
<li><p>共享锁（S）：允许事务读一行数据。</p>
</li>
<li><p>排他锁（X）：允许事务delete或update一行数据</p>
<p>S与S兼容，其它情况都不兼容。在使用索引进行检索时，InnoDB会加上S锁，这一点可能会引起大量的锁冲突，需要注意。</p>
</li>
</ul>
<p>​    表级锁包含意向共享锁和意向排他锁：</p>
<ul>
<li><p>意向共享锁（IS）：事务想要获得一个表中某几行的共享锁。</p>
</li>
<li><p>意向排他锁（IX）：事务想要获得一个表中某几行的排他锁。</p>
<p> 意向锁不会阻塞除全表扫描外的请求。</p>
</li>
</ul>
<p>​    可以通过三张表查询现在事务与锁的状态：</p>
<ul>
<li><p>INNODB_TRX：现在正在执行的事务的情况。</p>
</li>
<li><p>INNODB_LOCKS：现在锁的情况。</p>
</li>
<li><p>INNODB_LOCK_WAITS：现在被阻塞的事务与锁情况。</p>
<p> 如果在锁不兼容的情况下需要读取行的数据，就需要使事务读取行的一个快照数据。原理是通过Undo段回滚数据。一行可能有多个版本的快照数据，此时就需要多版本并发控制技术（MVCC）。在read committed的书屋隔离条件下，InnoDB使用非锁定的一致性读，总是读取被锁定行的最新一份快照数据，而在Repeatable的事务隔离级别下，InnoDB则是读取事务开始前的快照数据版本。</p>
</li>
</ul>
<p>​    在InnoDB中行锁的算法有3种，分别是：</p>
<ul>
<li><p>Record Lock：单个行记录上的锁；</p>
</li>
<li><p>Gap Lock：间隙锁，锁定除记录本身的范围；</p>
</li>
<li><p>Next-Key Lock：锁定一个范围并锁定记录本身，是默认的算法。</p>
</li>
</ul>
<p>​    当然锁虽然可以提高并发，满足事务的隔离性需求，但锁也带来了问题。</p>
<ul>
<li><p>丢失更新：事务的更新操作丢失。这是件非常严重的问题，尤其是在金融领域。想在数据库层面解决这个问题，就需要将操作串行化，按次序执行。</p>
</li>
<li><p>脏读：读到了未提交的数据，违反了隔离性。解决方案是将事务隔离级别提升到read uncommit。</p>
</li>
<li><p>不可重复读：一个事务多次读取同一数据期间数据被其他事务修改，导致两次读取的数据不一样。解决方案是将事务隔离级别提升到Read Repeatable。</p>
</li>
<li><p>死锁：A等待B，B等待A。解决方案是进行回滚操作，往往InnoDB会解决大多数的死锁。</p>
</li>
</ul>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a class="post-title-link" href="/2021/03/13/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1-%E5%BC%80%E7%AF%87/">开篇</a></h2><div class="post-info">2021年3月13日</div><div class="post-content"><p>​    算法与数据结构是程序员的内功之一，要想写出高质量高性能代码，优秀的算法基础是不可或缺的。这个系列将以python实现，探讨一些常用的算法与数据结构。</p>
<p>​    首先何为算法，我认为是推演计算寻求结果的方法。将解决问题的方法共性进行抽象而得出来的方式方法，从思想的层面而言，便是道。而数据结构则是在数组或链表的基础上附加特定的属性方法以获得性能的提升或所占存储空间的优化。为了量化程序的执行效率与存储空间的额外使用情况，引入了时间复杂度与空间复杂度。</p>
<p>​    时间复杂度是对代码执行效率的量化指标，即程序的执行次数，当程序的执行次数会由于某个变量变化时，我们以以变化函数来表示其复杂度。</p>
<p>我们输出一个正整数n：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(n)</span><br></pre></td></tr></table></figure>
<p>​    此程序的只需一次执行便可得到结果，我们可将其时间复杂度记为O(1)。</p>
<p>​    我们再来写一个简单的for循环输出1~n(正整数)：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>
<p>​    这个程序得运行次数取决于n值的大小不断变化，但始终为常数次，其时间复杂度我们便可记为O(n)。</p>
<p>​    怎么样是不是很简单？我们再来一题，输出n*n的矩阵：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    print(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        print(<span class="string">&quot;*&quot;</span>, end=<span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure>
<p>​    这个程序的执行次数为i<em>j，由于i与j相等于n，执行次数为n\</em>n，复杂度便可记为O(n^2^)。</p>
<p>​    以上的程序由于都没有额外开辟空间，所以空间复杂度皆为0。接下来我们举个简单的例子看下利用到额外空间的情况，换位:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">z=x</span><br><span class="line">x=y</span><br><span class="line">y=z</span><br></pre></td></tr></table></figure>
<p>​    此时我们运用到一个额外的空间Z，那么空间复杂度记为O(1)。</p>
<p>​    有没有感到复杂度的计算十分简单？当然，毕竟这才刚刚开始，之后会根据具体题目，逐渐深入。以下是常见复杂度的大小效率排序。</p>
<p>​    O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2^) &lt; O(n^3^) &lt; O(2^n^)</p>
<p>​    学习算法与数据结构是一件不是很愉快的事，那我们什么时候可以不用学算法与数据结构呢？现代科技的进步让设备的性能快速提升， 但至少就现在而言，性能依然是远远不够的，在实现相同结果的情况下，经过优化的代码在效率与存储空间的利用上往往强于未经优化的代码，如之后会提到的排序算法。我想等到设备的性能强悍到可以忽略代码上的优化提升（量子计算机），存储的成本变得极其低廉吧，希望有生之年可以遇到吧。</p>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a class="post-title-link" href="/2021/03/12/%E9%9A%8F%E6%83%B31/">腾讯业务运维初面复盘</a></h2><div class="post-info">2021年3月12日</div><div class="post-content"><p>​    腾讯的业务运维面试一直显示初始状态，应该是挂了。吃一堑长一智，这篇将对这次面试进行一个完整的复盘，保证错误不犯第二次。</p>
<ol>
<li><p>自我介绍</p>
<p>自我介绍的时候有些紧张，说得结结巴巴，没有啥逻辑性，这是个很大的问题，自我介绍这里需要精心地准备下。</p>
</li>
<li><p>聊下项目</p>
<p>用4台阿里云ECS虚拟机，其中一台由于和其他三台不在一个区域，在其上搭建测试环境与Showdoc文档中心。另外三台做了内网互通，一台配置了nginx作为负载均衡调度器，另外两台提供服务。数据库是mysql，做了主从。缓存用redis，也做了主从，监控选择使用Netdata。</p>
</li>
<li><p>mysql的主从的原理</p>
<p>从节点开了两个线程，I/O线程与SQL线程。I/O线程负责从Master节点读取Bin log到Relay log，Sql线程负责执行。</p>
</li>
<li><p>了解过主主嘛，具体配置过程。</p>
<p>主主就是互为主从，具体配置过程没有答上来，现在复盘来看，其实很简单，互为主从，不就是角色互换再配置一次主从，这个问题没答出来真是怪自己太菜。</p>
</li>
<li><p>你是进行过压测嘛，有哪些指标。</p>
<p>这个问题肯定是看到项目才问出来的。我事先没有准备，回答是用低轨道离子炮进行压测，看看能顶住多少流量。指标我只回答了三个，页面的响应时间，吞吐量，qps，回答的不行。</p>
</li>
<li><p>有没有尝试过用docker进行部署，怎样更安全地docker部署。</p>
<p>我的回答是尝试过，至于更安全的部署我直接说了kata。现在来看应该先回答，docker是直接在内核上隔离资源进行容器的创建，黑客可以直接通过容器攻击到内核，有安全隐患，所以可以创建KVM，在KVM中使用容器，这样即使容器收到攻击，也很难对宿主机造成危害。但这个方案的资源消耗较高，所以可以使用更加轻量化的VM与容器技术的结合方案，OpenStack基金会的kata，在VM层上创建容器，资源消耗更少。</p>
</li>
<li><p>TCP4次挥手</p>
<p>这个是基础，没啥好说的。</p>
</li>
<li><p>红黑树</p>
<p>这个在面试的时候有些紧张，答得很烂。</p>
</li>
<li><p>堆栈</p>
<p>堆在数据结构上的实现一般为二叉堆，斐波那契堆等，按照排列顺序分为最大堆，最小堆。栈的特点为元素后进先出。</p>
</li>
<li><p>模拟退火算法</p>
<p>没听说过，直接去世。</p>
</li>
</ol>
<p>​    以上是本次面试比较有价值的问题，总体来说答得非常不好，表述没有严谨，缺乏逻辑性。下次面试一定不能犯这些低级的错误。</p>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a class="post-title-link" href="/2021/03/10/Mysql%E4%B8%BB%E4%BB%8E/">Mysql主从</a></h2><div class="post-info">2021年3月10日</div><div class="post-content"><p>​    常见的Mysql高可用策略，Master配上Slave（可多个），Slave与Master的数据进行同步，当Master宕机时可以顶上去。</p>
<p>原理：</p>
<p>​    从节点开两个线程，一个线程负责读取主节点中的二进制日志到本机的relay日志，另一个线程负责执行。</p>
<p>​    有很多主从复制的方法，SBR（基于SQL语句复制）、RBR（基于行复制）、MBR（混合模式（默认使用SBR））以及现在Mysql版本的GITDs（基于事务复制）。</p>
<ul>
<li><p>SBR优势在于记录了所有语句，日志较小且方便日后审计。但弊端也较多，有些语句无法被正确地复制，有些语句会执行大量的行级锁。</p>
</li>
<li><p>RBR则是记录了数据变化，是较为安全的复制方式，并且有更少的行级锁，但相对而言日志较大，不能直接进行审计。</p>
</li>
<li><p>GITDs的优势在于完全基于事务，大大简化了复制过程。</p>
</li>
</ul>
<p>配置：</p>
<p>1.首先准备两台安装好Mysql的server，安装教程请看使用RPM安装安装Mysql。</p>
<p><strong>主节点：</strong></p>
<p>2.配置主节点my.cnf</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"></span><br><span class="line">log-bin=mysql-bin	<span class="comment">#开启二进制日志</span></span><br><span class="line"></span><br><span class="line">server-id=1		    <span class="comment">#配置服务器ID</span></span><br></pre></td></tr></table></figure>
<p>3.创建用户</p>
<p>​    从服务器需要账户来连接主服务器，一从一账号或者多从一账号</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">grant</span> replication slave <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;share&#x27;</span>@<span class="string">&#x27;10.1.1.%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;1234&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>​    如果出现以下报错：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR <span class="number">1819</span> (HY000): Your password does <span class="keyword">not</span> satisfy the <span class="keyword">current</span> policy requirements</span><br></pre></td></tr></table></figure>
<p>​    报错内容：您设置的密码不满足当前要求。请执行以下命令调整数据库的密码级别：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> <span class="keyword">global</span> validate_password_length<span class="operator">=</span><span class="number">4</span>; <span class="comment">--设置密码的长度为4</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> <span class="keyword">global</span> validate_password_policy<span class="operator">=</span><span class="number">0</span>; <span class="comment">--将策略级别设为0</span></span><br></pre></td></tr></table></figure>


<p><strong>从节点：</strong></p>
<p>1.配置my.cnf</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"></span><br><span class="line">server<span class="operator">-</span>id<span class="operator">=</span><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>2.配置同步参数</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> change master <span class="keyword">to</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> MASTER_HOST<span class="operator">=</span><span class="string">&#x27;10.1.1.133&#x27;</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> MASTER_USER<span class="operator">=</span><span class="string">&#x27;share&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>3.执行show slave status\G;</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Slave_IO_Running: connecting</span><br><span class="line">Slave_SQL_Running: <span class="keyword">No</span></span><br></pre></td></tr></table></figure>
<h3 id="双主"><a href="#双主" class="headerlink" title="双主"></a>双主</h3><p>​    master与slave可以做读写分离，增强读的性能，但如果从节点进行写入操作会使数据不一致，这就诞生了双主，两台mysql server互为主从，皆可读写。</p>
<p>​    配置方案与上面相似，但需要两步：</p>
<ol>
<li>执行show master status;命令查看bin日志。</li>
<li>在change master to 配置时需要加上MASTER_LOG_FILE=‘bin日志的名字’。</li>
</ol>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a class="post-title-link" href="/2021/03/10/%E4%BD%BF%E7%94%A8RPM%E5%AE%89%E8%A3%85Mysql/">RPM安装Mysql</a></h2><div class="post-info">2021年3月10日</div><div class="post-content"><p>​    官方文档推荐使用RPM的方式安装Mysql，中间存在着一些坑，本片文章将在CentOS上走一便完整的安装流程，供参考。</p>
<p>1.环境准备</p>
<p>​    wget用来下载mysql包，其他两个为必要依赖。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y perl net-tools wget</span><br></pre></td></tr></table></figure>
<p>2.卸载mariadb</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -e `rpm -qa | grep mariadb` --nodeps <span class="comment">#强制卸载mariadb</span></span><br></pre></td></tr></table></figure>
<p>3.下载</p>
<p>​    如果下载速度太慢，可以宿主机下载后用远程终端软件或rz（需yum install lrzsz）传到CentOS。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.13-1.el7.x86_64.rpm-bundle.tar</span><br></pre></td></tr></table></figure>
<p>4.解压</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xvf mysql-5.7.13-1.el7.x86_64.rpm-bundle.tar </span><br></pre></td></tr></table></figure>
<p>5.安装</p>
<p>​    存在依赖关系，需要按照顺序安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh mysql-community-common-5.7.13-1.el7.x86_64.rpm</span><br><span class="line">rpm -ivh mysql-community-libs-5.7.13-1.el7.x86_64.rpm</span><br><span class="line">rpm -ivh mysql-community-libs-compat-5.7.13-1.el7.x86_64.rpm</span><br><span class="line">rpm -ivh mysql-community-client-5.7.13-1.el7.x86_64.rpm </span><br><span class="line">rpm -ivh mysql-community-server-5.7.13-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure>
<p>6.启动</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start mysqld</span><br><span class="line">systemctl <span class="built_in">enable</span> mysqld</span><br></pre></td></tr></table></figure>
<p>7.获取临时密码</p>
<p>​    如果不想使用临时密码，请执行mysql_secure_installation，设置root密码，如果不会此命令，解决方案见文章末尾的附。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&#x27;temporary password&#x27;</span> /var/<span class="built_in">log</span>/mysqld.log</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">2021-03-10T01:53:22.381808Z 1 [Note] A temporary password is generated <span class="keyword">for</span> root@localhost: WngA:JiJa5=k</span><br></pre></td></tr></table></figure>
<p>8.使用临时密码登录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p(临时密码)</span><br></pre></td></tr></table></figure>


<p>附：到这里mysql就已经安装完成，如果嫌弃临时密码太长，就需要更改mysql的密码的安全策略，重新设置密码。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> <span class="keyword">global</span> validate_password_length<span class="operator">=</span><span class="number">4</span>; <span class="comment">--设置密码的长度为4</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> <span class="keyword">global</span> validate_password_policy<span class="operator">=</span><span class="number">0</span>; <span class="comment">--将策略级别设为0</span></span><br><span class="line">mysq<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">by</span> <span class="string">&#x27;1234&#x27;</span>; <span class="comment">--更改密码为1234</span></span><br></pre></td></tr></table></figure></div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a class="post-title-link" href="/2021/03/03/http/">HTTP</a></h2><div class="post-info">2021年3月3日</div><div class="post-content"><p>​    我们几乎每天都在网上冲浪，接收或发出大量的数据，而这些是怎样被表示并发送接收的的呢？今天就来聊聊处在TCP/IP模型应用层的HTTP协议。</p>
<p>​    中文名：超文本传输协议，是万维网的基础。服务器与用户通过这个协议完成了数据点到点的传输，Restful API也是基于它而定的一种架构标准。接下来直接进入正题，从http1.1版本开讲。</p>
<p>​    1.1的版本虽然已诞生许久，但依然经久不衰。其特点简而言之就是基于TCP连接，以请求-应答的方式进行交互，明文的方式进行传输，处理是无状态的。它的缺点也非常明显，其一，以明文的方式进行传输，数据安全性较低，其二，虽然已经采用keep-alive的连接方式，Pipeline的复用机制，但由于需要按次序处理，所以依然容易造成队头阻塞的问题。其三，报头偏重，浪费资源。至于无状态，这就要分场景而言，例如在直播领域无状态反而由于开销较小，成了个优势。</p>
<p><strong>HTTPS</strong></p>
<p>​    对于安全性这方面，前辈们选择添砖加瓦，创造了TLS/SSL协议，采用混合加密的方式保障信息的安全。这里的混合加密是指对称加密与非对称加密的结合。</p>
<p>​    对称加密是我们较为熟知的方式，发送方用一个密码进行加密，接收方再用这个密码解密，较好理解。非对称加密则是采用私钥与公钥这种密钥对的方式进行加密解密。公钥可对外发布，私钥自己保留，公钥可加密解密私钥发来的信息，私钥对公钥亦然，其原理可以去看下椭圆曲线加密算法。这种非对称加密最常见的应用实例就是HTTPS的身份验证。</p>
<p>​    权威的第三方机构生成密钥对，公钥加上一些机构和时间等信息形成证书，证书将直接内置于客户端，服务端则内置私钥与证书。在TCP连接建立完成后，客户端发送hello消息，说明自己支持的加密套件，服务端收到后回复hello信息，其中包含证书，选择的加密套件，客户端经过与内置的证书进行比对，确认无误后用此证书中的公钥加密对称密钥，回复给服务端，此后的信息都将进行对称加密。但是这里有个问题，如果server的hello信息被黑客截取，篡改了其中的证书信息，我们怎么来确定它的完整性呢？前辈们提出了数字签名的方案。服务端将证书的信息进行摘要计算（如MD5），再将摘要信息用私钥进行加密生成数字签名，和证书一同发送给客户端，客户端收到后，用公钥解密得到摘要信息，以相同的方式计算，如果得到相同结果则可以确认信息未被修改。</p>
<p><strong>HTTP2</strong></p>
<p>​    安全的问题已经解决，接下来解决性能的问题，HTTP2登场。</p>
<p>​    首先是HTTP2的第一个升级点，二进制分帧。将报文称之为消息，分成头报头帧和DATA帧，这些帧具有相同的ID。在传输时，同一ID的帧必须按顺序发送，不同ID的帧可以乱序发送。</p>
<p>​    第二个升级点，更好的多路复用。在HTTP1.1中，对单个域名的有6—8的TCP连接数量的限制。在HTTP2中，一个域名只需要一个TCP连接，这个连接可以承载不限数量的双向传输序列（这种双向传输序列被称为流）。</p>
<p>​    第三个升级点，头部压缩。服务器与客户端维持两个字典和一个表，静态字典（包含常见的头部方法与值，共61个表项），动态字典（可以动态添加）与静态哈夫曼表（对不包含在另两个字典的头部进行压缩）。当发送的报头在静态字典中时，一个字符即可表示，不在时则基于哈夫曼表进行编码发送，并且将这个包头加入到动态字典中，下次传输也只需要一个字符就可以代替。当然，这里讲的比较笼统，能否加入到动态字典也是有要求的，具体细节读者可查看<a target="_blank" rel="noopener" href="https://httpwg.org/specs/rfc7541.html">RFC7541</a>。</p>
<p>​    第四个升级点，加入PUSH方法。原来客户端解析网页时需要读取HTML取资源，而现在服务器可通过PUSH直接将HTML连同所需资源一同发到客户端，降低了延迟。</p>
<p>​    第五点，加入就请求优先级。HTTP2中每个请求消息都带有一个31bits的优先级，0为最高级，客户端和服务器可根据不同的优先级采取不同的处理策略。</p>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a class="post-title-link" href="/2021/02/24/%E5%BF%AB%E6%8E%92/">快排</a></h2><div class="post-info">2021年2月24日</div><div class="post-content"><p>​    今天突发奇想，能不能用更简洁的方式实现快排，说干就干。</p>
<p>首先来讲讲一般的普通解法，以升序为例，选择一个基值（一般为第一个数），将其放在中间位置，定义两个游标，从左边寻找比基值大的，从右边找比基值大的，左右两个游标交换位置，继续执行此操作，直到两个指针相遇，一轮结束。然后开始下一轮操作，对基数左右两边的数继续执行上述操作，直到排序成功。</p>
<p>​    上面是快排的最基本思路，利用递归可以轻易实现，那么可不可以再简易一些，更让人容易理解一些呢？</p>
<p>​    简单分析一下可以发现，每轮操作的最终目的都是将比基值大的数放在基值右边，比基值小的放在基值左边，此时就可以换个思路，进行遍历操作，遇到比基值小的，与左游标交换，遇到比基值大的，与右游标交换，相等则跳过，以下是代码实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort_1</span>(<span class="params">sorting, left, right</span>):</span></span><br><span class="line">    <span class="keyword">if</span> right &lt;= left: 	<span class="comment">#判断左右游标是否相遇</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    a = i = left</span><br><span class="line">    b = right</span><br><span class="line">    pivot = sorting[left]	<span class="comment">#设第一个数为基值</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= b:</span><br><span class="line">        <span class="comment">#如果遍历的值小于基值，与左游标交换</span></span><br><span class="line">        <span class="keyword">if</span> sorting[i] &lt; pivot:	</span><br><span class="line">            sorting[a], sorting[i] = sorting[i], sorting[a] </span><br><span class="line">            a += <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="comment">#如果遍历的值大于基值，与右游标交换</span></span><br><span class="line">        <span class="keyword">elif</span> sorting[i] &gt; pivot:</span><br><span class="line">            sorting[b], sorting[i] = sorting[i], sorting[b]</span><br><span class="line">            b -= <span class="number">1</span></span><br><span class="line">        <span class="comment">#如果等于则跳过</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="comment">#递归左边的数据</span></span><br><span class="line">    quick_sort_1(sorting, left, a - <span class="number">1</span>)</span><br><span class="line">    	<span class="comment">#递归右边的数据</span></span><br><span class="line">    quick_sort_1(sorting, b + <span class="number">1</span>, right)</span><br></pre></td></tr></table></figure>
<p>​    此代码更容易理解，让我们更近一步，再抽象一些，整个快排的操作都在做一件什么事？基值在中间，将大于基值的数放到右边，小于基值的数放到左边，不断地重复这样的操作。直接上代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort_2</span>(<span class="params">a</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(a) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    q = a[<span class="number">0</span>]</span><br><span class="line">    g = [e <span class="keyword">for</span> e <span class="keyword">in</span> a[<span class="number">1</span>:] <span class="keyword">if</span> e &gt; q]</span><br><span class="line">    le = [e <span class="keyword">for</span> e <span class="keyword">in</span> a[<span class="number">1</span>:] <span class="keyword">if</span> e &lt;= q]</span><br><span class="line">    <span class="keyword">return</span> quick_sort_2(le) + [q] + quick_sort_2(g)</span><br></pre></td></tr></table></figure>


</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a class="post-title-link" href="/2021/02/07/%E8%99%9A%E6%8B%9F%E5%8C%96/">虚拟化技术</a></h2><div class="post-info">2021年2月7日</div><div class="post-content"><p>​    在这云计算风靡的科技时代，虚拟化技术是不可获缺的一环，是前提，是基石。</p>
<h3 id="一、什么是虚拟化"><a href="#一、什么是虚拟化" class="headerlink" title="一、什么是虚拟化"></a>一、什么是虚拟化</h3><p>​    简而言之，一种将硬件资源抽象转化并利用的技术，再简单一些，就是将硬件资源池化（池化是一个非常优秀的技术思想，之后会有文章专门阐述）。这里的硬件资源指的是内存，CPU，存储，网络或显卡等计算机所具备的物理资源，虚拟化技术将这些资源变成了”池子“，这样便可以在一台物理机上建立多个虚拟机，最大限度地运用这些资源。当然，这样的过程肯定会有性能的损耗，不过随着技术水平的不断提高，损耗已不值一提。</p>
<h3 id="二、虚拟化技术的分类"><a href="#二、虚拟化技术的分类" class="headerlink" title="二、虚拟化技术的分类"></a>二、虚拟化技术的分类</h3><p>​    根据VMM（又称Hypervisor，虚拟化的管理程序）分类，可分为Type1和Type2，Type1是在直接在物理设备上安装VMM进行资源抽象，其实现需要对操作系统的源码进行魔改，而Type2则不同，依然需要安装在操作系统上。</p>
<p>​    从支持程度而言，可分为软件虚拟化和硬件虚拟化。软件虚拟化是通过软件将虚拟机的指令翻译给宿主机执行，消耗较高。硬件虚拟化则可以在硬件层面直接执行虚拟机的指令，效率较高。</p>
<p>​    从虚拟化的程度程度而言，可分为半虚拟化（又称准虚拟化）和全虚拟化。半虚拟化技术是虚拟机知道自己运行在虚拟环境，虚拟机的操作系统可以主动通知指令到宿主机，减轻了VMM截获指令的要求，可以提升性能并且使虚拟化技术实现更加简单，不过需要更改虚拟机操作系统的源码或安装驱动以获得支持。全虚拟化就是完全模拟出与物理机一摸一样的平台给虚拟机，虚拟机无需任何更改。</p>
<h3 id="三、虚拟化产品"><a href="#三、虚拟化产品" class="headerlink" title="三、虚拟化产品"></a>三、虚拟化产品</h3><h4 id="1-Xen"><a href="#1-Xen" class="headerlink" title="1. Xen"></a>1. Xen</h4><p>​    从剑桥大学诞生的非常老牌的虚拟化技术，其历史可追溯到20世纪90年代，是Type1的半虚拟化技术，现在依然活跃于各大云计算厂商。Xen由VMM完全控制物理资源，所以准确地来说，它没有宿主机的概念，用户其实是通过Dom0虚拟机和tool stack来控制其它虚拟机。</p>
<h4 id="2-KVM"><a href="#2-KVM" class="headerlink" title="2. KVM"></a>2. KVM</h4><p>​    后起之秀，诞生于以色列的一家公司，之后被redhat收购。与Xen不同的在于它是一种type2的全虚拟化技术。一台KVM虚拟机对应宿主机inux的一个进程，一个vCPU对应进程中的一个线程，进程中还有单独用来处理I/O的线程。其内存管理也依赖于Linux，即Linux的内存管理技术直接用于虚拟机，如共享内存，KSM，大页和NUMA等。</p>
<h4 id="4-Vmware"><a href="#4-Vmware" class="headerlink" title="4. Vmware"></a>4. Vmware</h4><p>​    最早专注于虚拟化并成功的公司。其旗下两个非常著名的主力产品，workstation和ESXI，前者是type2的桌面级虚拟化产品，后者是type1的服务器级虚拟化产品。</p>
<h4 id="5-HyperV"><a href="#5-HyperV" class="headerlink" title="5. HyperV"></a>5. HyperV</h4><p>​    微软的Type1虚拟化技术，与Xen类似。</p>
</div></article></li></ul></main><footer><div class="paginator"><a class="next" href="/page/2/">下一页</a></div><div class="copyright"><p>© 2020 - 2021 <a href="http://yoursite.com">Tian</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/claymcleod/hexo-theme-hermes" target="_blank">hexo-theme-hermes</a>. </p><p>Logo made by <a target="_blank" rel="noopener" href="https://www.flaticon.com/authors/freepik">Freepik</a> from <a target="_blank" rel="noopener" href="https://flaticon.com">www.flaticon.com</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>